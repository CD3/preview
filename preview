#! /bin/bash

entr=$(which entr)
make=$(which make)
getopt=$(which getopt)


if [[ -z $entr ]]
then
        echo ''entr' is required to run 'preview' but was not found. Please install it and run again.'
        exit 1
fi

if [[ -z $make ]]
then
        echo ''make' is required to run 'preview' but was not found. Please install it and run again.'
        exit 1
fi

if [[ -z $getopt ]]
then
        echo ''getopt' is required to run 'preview' but was not found. Please install it and run again.'
        exit 1
fi


function print_usage()
{

cat <<EOF
Usage: preview [options] [SOURCE FILE] [ADDITIONAL FILES TO WATCH...]

Options:
      -v --verbose              | Increase verbose level.
      -d --debug                | Set verbose level to maximum.
      -f --makefile             | FILE Use FILE instead of default makefile.
      -h --handler HANDLER      | Use HANDLER for preview handler rather than detecting.
      -l --local_link LEXT:GEXT | Create a Makefile symlink in current directory with extension LEXT to a global Makefile in ~/.preview with extension GEXT
EOF

}

function print_help()
{
cat <<EOF
'preview' allows you to quickly preview a file from its source, for example markdown files.
It uses the 'entr' command to monitor the source file and automatically update the preview.
If additional files are passed, the preview will be updated when any of them change.

'preview' uses a makefile to execute the commands required to build, view, and refresh the preview.
If a makefile is found in the current directory, it will be used, otherwise a default makefile is used.
If you choose to use your own makefile, you must define the following targets

setup - This target is ran once before the 'start' target. It can be used to create/setup any files needed by the 'start' target.

start - This target is ran once to start the "viewing" process that will run during the entire preview. The preview will be stopped when this processed is killed/closed by the user.

refresh - This target will be run every time the file being previewed is saved.

stop - This target will be called when 'preview' recieves a SIGTERM. It should perform any of the necessary cleanup.

cleanup - This target will be run on normal exit (after the "viewing" process has terminated). It should perform any of the necessary cleanup.

These targets are optional.

logfile - This target should print the name of the log file (the file that command output will be directed too by 'preview')
          By default, 'preview' directs output to /dev/stdout.
          NOTE: this should ONLY print the name of the file. If this is being generated by a command, you should put a '@' in front
          of the command so that it is not echo'ed by 'make'

These variables will be passed into the makefile by 'preview', and can be used in your targets.

INFILE_ABS   - the absolute path name name of the source file to be previewed.
INFILE_NAME  - the name of the source file to be previewed without the directory.
INFILE_STEM  - the name of the source file to be previewed without the extention.
INFILE_EXT   - the extension of the source file to be previewed.
INDIR        - the directory containing the source file.
TMPDIR       - the name of a temperary directory that has been created by 'preview'. If you want the output files to be generated in a temp
               directory, you should prepend the output filename with this directory.
LOGFILE      - the name of a file that command output will be written to.
INFILE       - the absolute path name name of the source file to be previewed. this var name is deprecated, use INFILE_ABS instead

Dependencies:
  Required:
    - getopt: command line parser for shell scripts (should already be installed)
    - make: preview uses Makefiles for callbacks
    - entr: A small utility for triggering commands when a file is modified.

Useful Tools for the Makefiles:
    - pandoc : a document converter that can generate PDFs from Markdown.
    - sexpect: a tool for starting and controlling interactive processes (like gnuplot).
    - grip: a python module and command line tool for previewing markdown in a browser.

EOF
}

# https://en.wikipedia.org/wiki/Syslog#Severity_level
declare -A LOG_LEVELS
LOG_LEVELS=([0]="error" [1]="info" [2]="debug")
function .log () {
  local LEVEL=${1}
  shift
  if [ ${verbose_level} -ge ${LEVEL} ]; then
    echo "[${LOG_LEVELS[$LEVEL]}]" "$@"
  fi
}



# the getopt command is external to the shell. essentially what it
# does is parse the command line parameters and rearrange them so
# that all of the options are given before any of the arguments, and
# adds a '--' between the options and arguments. 
# then you can setup a while loop to process options easily and terminate
# it when you run into the '--'
NEW_COMMAND_LINE=$(getopt -o hfc::vdl: -l help,makefile:,config-dir:,verbose,debug,handler:,local-link: -n preview -- "$@")   # this creates a rearranged version of the command line
if [ "$?" != "0" ] ; then echo "There was an error parsing the command line." >&2; exit 1 ; fi
eval set -- "$NEW_COMMAND_LINE"


verbose_level=0
makefile=""
configdir="${HOME}/.preview"
handler=""
local_link=""
while true ; do
  case "$1" in
    -h|--help)
        print_help
        print_usage
        exit;
        ;;
    -v|--verbose)
        verbose_level=$(($verbose_level + 1))
        shift 1
        ;;
    -d|--debug)
        verbose_level=2
        shift 1
        ;;
    -f|--makefile)
        makefile=$2
        shift 2
        ;;
    -c|--config-dir)
        configdir=$2
        shift 2
        ;;
    --handler)
        handler=$2
        shift 2
        ;;
    -l|--local-link)
        local_link="$2"
        shift 2
        ;;
    --) shift ; break ;;
     *) .log 0 "Unreconized option got through: '$1'" ; exit 1 ;;
  esac
done
# handle options that don't require argument
if [[ "x$local_link" != "x" ]]
then
    local_ext=$(echo $local_link | awk -F: '{print $1}')
    global_ext=$(echo $local_link | awk -F: '{print $2}')
    local_file="Makefile.$local_ext"
    global_file="Makefile.$global_ext"

    link_cmd="ln -s $configdir/$global_file $local_file"
    .log 2 "$link_cmd"
    if [[ -e $local_file ]]
    then
            if [[ -L "$local_file" ]]
            then
                    rm $local_file
            else
                    echo "Target file '$local_file' exists and is not a symlink. Please remove it and rerun if you really want to override it."
                    exit 1
            fi
    fi
    if [[ ! -e $configdir/$global_file ]]
    then
            echo "Did not find '$global_file' in $configdir. Did you spell the extension correctly?"
            exit 1
    fi
    eval $link_cmd
exit 0
fi

# arguments start at $1...
ifile=${1}
shift






if [[ "x${ifile}" == "x" ]]
then
        print_usage
        exit 0
fi

if [ ! -f "$ifile" ]; then
  .log 0 "Input file '${ifile}' does not exist or is not a file."
  exit 1
fi






tmpdir=$(mktemp -d)
ifile=$(readlink -f "$ifile")
idir=$(dirname "$ifile")
ifile_name=$(basename $ifile)
ifile_ext="${ifile_name##*.}"
ifile_stem="${ifile_name%.*}"
pidfile="${tmpdir}/pids"


# try to find a makefile
[[ -z $handler ]] && handler=${ifile_ext}
makefiles_checked=()
if [ ! -e "$makefile" ]
then
  makefiles_checked+=($makefile)
  # look for a Makefile with the same extension as the input file
  # in the same directory as the input file
  makefile="$idir/Makefile.$handler"
fi

if [ ! -e "$makefile" ]
then
  makefiles_checked+=($makefile)
  # look for a Makefile with the same extension as the input file
  # in the .preview directory
  makefile="$HOME/.preview/Makefile.$handler"
fi

if [ ! -e "$makefile" ]
then
  makefiles_checked+=($makefile)
  # look for a Makefile
  # in the same directory as the input file
  makefile="$idir/Makefile"
fi

if [ ! -e "$makefile" ]
then
  makefiles_checked+=($makefile)
  # look for a Makefile in the directory we where called from
  makefile="$HOME/.preview/Makefile"
fi


if [ ! -e "$makefile" ] 
then
        .log 0 "Could not find a Makefile to use."
        .log 0 "Looked for the following files:"
        for file in "${makefiles_checked[@]}"
        do
                .log 0 "$file"
        done
        exit 1
fi


.log 2 "Using '$makefile' for makefile"


make="$make -f $makefile"
make="$make INFILE=${ifile}"
make="$make INFILE_ABS=${ifile}"
make="$make INFILE_NAME=${ifile_name}"
make="$make INFILE_EXT=${ifile_ext}"
make="$make INFILE_STEM=${ifile_stem}"
make="$make INDIR=${idir}"
make="$make TMPDIR=${tmpdir}"
make="$make PIDFILE=${pidfile}"
.log 2 "make cmd: $make"

# get log filename
if $make logfile > /dev/null 2>&1
then
  lfile=$($make logfile)
else
  lfile="preview.log"
fi
if [ ${verbose_level} -ge 1 ]; then
STDOUT="/dev/stdout"
else
STDOUT="/dev/null"
fi
if [ ${verbose_level} -ge 0 ]; then
STDERR="/dev/stderr"
else
STDERR="/dev/null"
fi

make="$make LOGFILE=${lfile}"




.log 2 "variables:"
.log 2 "INFILE_ABS: $ifile"
.log 2 "INFILE_NAME: $ifile_name"
.log 2 "INFILE_STEM: $ifile_stem"
.log 2 "INFILE_EXT: $ifile_ext"
.log 2 "INFILE: $ifile"
.log 2 "LOGFILE: $lfile"
.log 2 "INDIR: $idir"
.log 2 "TMPDIR: $tmpdir"
.log 2 "PIDFILE: $pidfile"



function kill_if_running()
{
  # check that a proc is alive and then kill it
  for PID in ${*}
  do
    if kill -s 0 $PID > /dev/null 2>&1
    then
      kill $PID
    fi
  done
}

function family_tree()
{
  local PID
  for PID in ${*}
  do
    family_tree $(ps -o pid= --ppid "$PID")
    echo $PID
  done
}


function kill_saved_procs()
{
  # kill procs saved in text file
  for file in ${*}
  do
    [[ -f $file ]] && kill_if_running $( family_tree $(cat $file) )
  done
}

_stop() {
        .log 2 "Running 'make stop'..."
        $make stop > >( tee -a ${lfile} > $STDOUT) 2> >(tee -a ${lfile} > $STDERR)
}
_cleanup() {
        .log 2 "Running 'make cleanup'..."
        $make cleanup > >( tee -a ${lfile} > $STDOUT) 2> >(tee -a ${lfile} > $STDERR)
        .log 2 "Making sure child procs that were created are cleaned up..."
        kill_if_running $offspringPIDS
        kill_saved_procs $pidfile
        # check for any other processes in our process group
        kill_if_running $(ps -o pgid=,pid= | grep "^ *$$" | sed "s/^ \+[0-9]\+ \+//" | grep -v $$)
}
trap _stop SIGTERM
trap _stop SIGINT
trap _cleanup EXIT




PGID=$(ps -o pgid= $$)



$make setup > >( tee -a ${lfile} > $STDOUT) 2> >(tee -a ${lfile} > $STDERR)
$make start > >( tee -a ${lfile} > $STDOUT) 2> >(tee -a ${lfile} > $STDERR) &
startPID=$!
sleep 0.1
offspringPIDS=$(family_tree $startPID)

echo $ifile > "$tmpdir/files.txt"
for file in "${@}"
do
  readlink -f "${file}" >> "$tmpdir/files.txt"
done

cat $tmpdir/files.txt | $entr $make refresh > >( tee -a ${lfile} > $STDOUT) 2> >(tee -a ${lfile} > $STDERR) &
entrPID=$!
sleep 0.1
offspringPIDS="$offspringPIDS $(family_tree $entrPID)"




.log 2 "entr PID: $entrPID"
.log 2 "start PID: $startPID"
.log 2 "offspring PIDs: $offspringPIDS"
.log 2 "group ID: $PGID"
wait $startPID
