#! /bin/bash

ENTR=$(which entr)
MAKE=$(which make)

if [[ -z $ENTR ]]
then
        echo '`entr` is required to run `preview` but was not found. Please install it and run again.'
        exit 1
fi

if [[ -z $MAKE ]]
then
        echo '`make` is required to run `preview` but was not found. Please install it and run again.'
        exit 1
fi



function print_usage()
{
cat <<EOF
Usage: preview [options] [FILE]

'preview' allows you to quickly preview a file from its source, for example markdown files.
It uses the 'entr' command to monitor the source file and automatically update the preview.

'preview' uses a makefile to execute the commands required to build, view, and refresh the preview.
If a makefile is found in the current directory, it will be used, otherwise a default makefile is used.
If you choose to use your own makefile, you must define the following targets

setup - This target is ran once before the `start` target. It can be used to create/setup any files needed by the `start` target.

start - This target is ran once to start the "viewing" process that will run during the entire preview. The preview will be stopped when this processed is killed/closed by the user.

refresh - This target will be run every time the file being previewed is saved.

stop - This target will be called when `preview` recieves a SIGTERM. It should perform any of the necessary cleanup.

cleanup - This target will be run on normal exit (after the "viewing" process has terminated). It should perform any of the necessary cleanup.

These targets are optional.

logfile - This target should print the name of the log file (the file that command output will be directed too by 'preview')
          By default, 'preview' directs output to /dev/stdout.
          NOTE: this should ONLY print the name of the file. If this is being generated by a command, you should put a '@' in front
          of the command so that it is not echo'ed by 'make'

These variables will be passed into the makefile by 'preview', and can be used in your targets.

INFILE_ABS   - the absolute path name name of the source file to be previewed.
INFILE_NAME  - the name of the source file to be previewed without the directory.
INFILE_STEM  - the name of the source file to be previewed without the extention.
INFILE_EXT   - the extension of the source file to be previewed.
INDIR        - the directory containing the source file.
TMPDIR       - the name of a temperary directory that has been created by 'preview'. If you want the output files to be generated in a temp
               directory, you should prepend the output filename with this directory.
LOGFILE      - the name of a file that command output will be written to.
INFILE       - the absolute path name name of the source file to be previewed. this var name is deprecated, use INFILE_ABS instead

Dependencies:
  Required:
    - getopt: command line parser for shell scripts (should already be installed)
    - make: preview uses Makefiles for callbacks
    - entr: A small utility for triggering commands when a file is modified.

Useful Tools for the Makefiles:
    - pandoc : a document converter that can generate PDFs from Markdown.
    - sexpect: a tool for starting and controlling interactive processes (like gnuplot).
    - grip: a python module and command line tool for previewing markdown in a browser.

You can run:
  > preview -p
to see the makefile that is used by 'preview' by default.

Options:
      -p --print-makefile  Print the makefile that will be used and exit.
      -f --makefile FILE Use FILE instead of default makefile.


EOF
}

declare -A LOG_LEVELS
# https://en.wikipedia.org/wiki/Syslog#Severity_level
LOG_LEVELS=([0]="error" [1]="info" [2]="debug")
function .log () {
  local LEVEL=${1}
  shift
  if [ ${__VERBOSE} -ge ${LEVEL} ]; then
    echo "[${LOG_LEVELS[$LEVEL]}]" "$@"
  fi
}

# the getopt command is external to the shell. essentially what it
# does is parse the command line parameters and rearrange them so
# that all of the options are given before any of the arguments, and
# adds a '--' between the options and arguments. 
# then you can setup a while loop to process options easily and terminate
# it when you run into the '--'

# both long and short options can be given
# short options are passed to -o
# long  options are passed to -l
# a colon (:) after an option means it has a required argument
# two colons (::) after an option means it has a optional argument


NEW_COMMAND_LINE=$(getopt -o hpf:v -l print_makefile,help,makefile:,verbose -n preview -- "$@")   # this creates a rearranged version of the command line
if [ $? != 0 ] ; then .log 0 "getopt returned an error, Terminating..." >&2 ; exit 1 ; fi
eval set -- "$NEW_COMMAND_LINE"                                                                          # this sets up positional parameters to the new command line


# now we can just manually loop through the positional parameters
print_makefile=0
makefile=""
__VERBOSE=0
while true ; do
  case "$1" in
    -h|--help)
        print_usage
        exit;
        ;;
    -v|--verbose)
        __VERBOSE=$(($__VERBOSE + 1))
        shift 1
        ;;
    -p|--print_makefile)
        print_makefile=1
        shift 1
        ;;
    -f|--makefile)
        makefile=$2
        shift 2
        ;;
    --) shift ; break ;;
     *) .log 0 "Unreconized option got through: '$1'" ; exit 1 ;;
  esac
done

# arguments start at $1...
ifile=${1}
shift

if [ $print_makefile -eq 0 ]; then
  if [ ! -e "$ifile" ]; then
    last_ifile=$(cat ~/.preview/last_ifile || echo "")
    if which zenity > /dev/null 2>&1 
    then
      ifile=$(zenity --file-selection --title="Select a file." --filename=${last_ifile} 2>/dev/null)
    elif which Xdialog > /dev/null 2>&1 
    then
      ifile=$(Xdialog --no-buttons -fselect "$last_ifile" 0 0 2>&1)
    elif which dialog > /dev/null 2>&1
    then
      ifile=$(dialog --fselect '' 0 0)
    else
      read -p "What file would you like to preview?" ifile
    fi
  fi
fi

if [ ! -f "$ifile" ]; then
  .log 0 "Input file '${ifile}' does not exist or is not a file."
  exit 1
fi

tmpdir=$(mktemp -d)

# try to find a makefile
wd=$(dirname $ifile) # directory that the source file is in
ext=${ifile##*.}     # extension of the source file

if [ ! -e "$makefile" ]
then
  # look for a Makefile with the same extension as the input file
  # in the same directory as the input file
  makefile="$wd/Makefile.$ext"
fi

if [ ! -e "$makefile" ]
then
  # look for a Makefile with the same extension as the input file
  # in the .preview directory
  makefile="$HOME/.preview/Makefile.$ext"
fi

if [ ! -e "$makefile" ]
then
  # look for a Makefile
  # in the same directory as the input file
  makefile="$wd/Makefile"
fi

if [ ! -e "$makefile" ]
then
  # look for a Makefile in the directory we where called from
  makefile="$HOME/.preview/Makefile"
fi


if [ ! -e "$makefile" ] 
then
# create a makefile
makefile=${tmpdir}/Makefile
cat >$makefile << 'EOF'
.PHONY: logfile
logfile:
	@echo ./preview.log

.PHONY: build
build:
	pandoc -f markdown -t latex -o $(TMPDIR)/$(INFILE_STEM).pdf $(INFILE) || zenity --error --no-markup --text="There was a problem building the preview.\nCommand output was saved to $(LOGFILE)."

.PHONY: setup
setup: build

.PHONY: start
start:
	zathura $(TMPDIR)/$(INFILE_STEM).pdf 1>/dev/null 2>/dev/null

.PHONY: refresh
refresh: build

.PHONY: stop
stop:

.PHONY: cleanup
cleanup:

EOF
fi


.log 2 "Using '$makefile' for makefile"

if [ $print_makefile -eq 1 ]
then
  cat $makefile
  exit
fi

# exit if no input file was found
if [ ! -e "$ifile" ]; then
  exit 1
fi


ifile=$(readlink -f $ifile)
idir=$(dirname $ifile)
ifile_name=$(basename $ifile)
ifile_ext="${ifile_name##*.}"
ifile_stem="${ifile_name%.*}"

echo $ifile > ~/.preview/last_ifile
make="$MAKE -f $makefile INFILE=${ifile} INFILE_ABS=${ifile} INFILE_NAME=${ifile_name} INFILE_EXT=${ifile_ext} INFILE_STEM=${ifile_stem} INDIR=${idir} TMPDIR=${tmpdir}"
.log 2 $make

# get log filename
if $make logfile > /dev/null 2>&1
then
  lfile=$($make logfile)
else
  if [ ${__VERBOSE} -ge 1 ]; then
    lfile="/dev/stdout"
  else
    lfile="/dev/null"
  fi
fi

make="$make LOGFILE=${lfile}"




.log 3 "variables:"
.log 3 "INFILE_ABS: $ifile"
.log 3 "INFILE_NAME: $ifile_name"
.log 3 "INFILE_STEM: $ifile_stem"
.log 3 "INFILE_EXT: $ifile_ext"
.log 3 "INFILE: $ifile"
.log 3 "LOGFILE: $lfile"
.log 3 "INDIR: $idir"
.log 3 "TMPDIR: $tmpdir"

_stop() {
        .log 2 "Running 'make stop'..."
        $make stop >> ${lfile} 2>&1
}
_cleanup() {
        .log 2 "Running 'make cleanup'..."
        $make cleanup >> ${lfile} 2>&1
        .log 2 "Making sure child processed have been cleaned up..."
        for pid in $startPIDs $startPID $entrPIDs $entrPID
        do
                if kill -s 0 $pid > /dev/null 2>&1
                then
                        kill $pid
                fi
        done
}
trap _stop SIGTERM
trap _stop SIGINT
trap _cleanup EXIT

list_children()
{
  local children=$(ps -o pid= --ppid "$1")

  for pid in $children
  do
    list_children "$pid"
  done

  echo "$children"
}

$make setup >> ${lfile} 2>&1
$make start >> ${lfile} 2>&1 &
startPID=$!
sleep 0.1

echo $ifile | $ENTR sh -c "$make refresh" >> ${lfile} 2>&1 &
entrPID=$!

sleep 0.1

startPIDs=$(list_children $startPID)
entrPIDs=$(list_children $entrPID)


.log 2 "entr PID: $entrPID"
.log 2 "start PID: $startPID"
wait $startPID
kill $entrPID
